<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>docker on Yongfu's Blog</title><link>https://yongfu.name/tags/docker/</link><description>Recent content in docker on Yongfu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 20 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://yongfu.name/tags/docker/feed.xml" rel="self" type="application/rss+xml"/><item><title>以 Python 實作 Concordancer</title><link>https://yongfu.name/2020/03/20/building-concordancer/</link><pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate><guid>https://yongfu.name/2020/03/20/building-concordancer/</guid><description>&lt;p>每次接近學期末的時候，寫程式癮就會開始發作 (可能是不想面對無趣的期末報告)，這時候腦袋會蹦出許多很有趣的想法，然後就會迫不及待地想將這些想法實作出來。這次(2019 年末) 的程式癮刺激來源是實驗室的雲端硬碟裡的某個 (版權封閉) 中文語料庫，雖然該語料庫已有很好的搜尋界面，但&lt;strong>我就是想 reinvent the wheel&lt;/strong>，自己手刻出一個 concordancer。不為了什麼，就只是因為這件事本身就很有樂趣。&lt;/p>
&lt;h2 id="初步嘗試for-loop-forever">初步嘗試：for loop&amp;hellip; forever&lt;/h2>
&lt;p>我本來並沒有太大的雄心壯志，就只想快速弄出個程式界面方便我查找 concordance，想說使用 &lt;a href="https://www.nltk.org/book/ch01.html#searching-text">NLTK concordance&lt;/a> 應該很快就可以弄出我想的東西。但 NLTK concordance 只能使用 word form (或 pattern) 去搜尋 concordance，我的需求卻是要能&lt;strong>使用 word form 或 PoS tag&lt;/strong> 搜尋語料庫 (類似 &lt;a href="http://cwb.sourceforge.net/files/CQP_Tutorial/CQP_Tutorial.html">Corpus Query Langauge&lt;/a>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，但不用這麼複雜)。但要自己用 Python 實作這個功能也頗簡單，於是我就自己手刻了這個功能。然而事實證明我太過天真了。語料庫的大小約 1000 萬個 token，而每次搜尋時，我的程式使用 for 迴圈跑過整個語料，因此要花非常非常非常久的時間才能完成搜尋。對於非資訊背景出生的我，第一次體驗 $O(n)$ 是件不可忽視的問題以及 Database 存在的必要性。&lt;/p>
&lt;h2 id="重新規劃-database--python--vue">重新規劃： Database + Python + Vue&lt;/h2>
&lt;p>為了解決上述問題我暫時擱置了這個專案 (寒假開始到春節期間) 去學習必備的一些知識&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>，最後比較有系統地重新規劃了這個 concordancer 的架構：&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>這個新的架構分成前&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>、後端，前端不是本文的重點 (原始碼&lt;a href="https://github.com/liao961120/kwic">在此&lt;/a>)，就不細談。這邊直接舉一個實例說明這個 concordancer 如何運作：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先，使用者在前端輸入一個搜尋的字串 (keyword)，這個字串需符特定的格式：&lt;code>[token 1][token 2][token 3]&lt;/code>。每對中括號代表一個 token，中括號內則是描述此 token 的特徵，如 word form 與 PoS tag，例如 &lt;code>[word=&amp;quot;打&amp;quot; pos=&amp;quot;V.*&amp;quot;]&lt;/code> 即是要搜尋 word form 為 &lt;code>打&lt;/code> 且詞類為動詞&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> 的 token。這裡的例子使用 &lt;strong>&lt;code>[word.regex=&amp;quot;^[他她]$&amp;quot;][word=&amp;quot;打&amp;quot; pos=&amp;quot;V.*&amp;quot;]&lt;/code>&lt;/strong>，下方的幾個例子都是符合這個搜尋的 2-gram:&lt;/p>
&lt;ul>
&lt;li>&lt;code>他/Nh 打/VC&lt;/code>&lt;/li>
&lt;li>&lt;code>她/Nh 打/VC&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>[word.regex=&amp;quot;^[他她]$&amp;quot;][word=&amp;quot;打&amp;quot; pos=&amp;quot;V.*&amp;quot;]&lt;/code>&lt;/strong> 在傳給後端後，會先經過一個 &lt;a href="https://yongfu.name/kwic-backend/html/doc/queryParser.html">parser&lt;/a> 處理，讓後端可以將這個 query 轉換成 SQL 去搜尋 database。在搜尋時，這邊僅會在 DB 中以&lt;strong>其中一個 token 的資訊進行搜尋&lt;/strong>，並回傳所有符合的 token 於語料庫中的位置 (所在文件之 id、第幾個句子、token 於句子中的次序)。這些 token 是&lt;strong>可能符合 keyword pattern 的「候選者」&lt;/strong> ，讓接下來的 n-gram 比對可以更快速 (search space 從整個語料庫減少到只剩這些「候選者」所組成的 n-gram)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>透過這些 token 的位置資訊，可以找出含有該 token 的 n-gram。例如，假設這裡使用 &lt;code>[word=&amp;quot;打&amp;quot; pos=&amp;quot;V.*&amp;quot;]&lt;/code> 在 DB 當中搜尋，取得結果後，可以再比對此 token &lt;strong>左邊&lt;/strong>的 token 是否符合 &lt;code>[word.regex=&amp;quot;^[他她]$&amp;quot;]&lt;/code>。若符合，則保留此 2-gram，並取得該 2-gram 左右的 context，作為未來要回傳給使用者的 KWIC concordance。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>跑完所有的「候選者」token，即可取得整個語料庫內，符合 keyword pattern 的 concordance。接下來僅需將資料轉換成 JSON 格式再傳到前端即可。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="database-設計">Database 設計&lt;/h2>
&lt;p>下圖是 Database&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup> 的 table 設計，共有 3 個 table:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>&lt;strong>Token&lt;/strong>: 將語料庫中的每種 token (即 type) 對應至 id。如此搜尋單一 token 的 word form 時，即可搜尋此較小的 table (列數等於語料庫中 type 的數量)，而不用跑過整個語料庫。&lt;/li>
&lt;li>&lt;strong>Pos&lt;/strong>: 將語料庫中的每種 PoS tag 對應至 id。同上，可以快速找出符合的 token。&lt;/li>
&lt;li>&lt;strong>Corpus&lt;/strong>: 保留語料庫 token 位置資訊的 table。搜尋完 &lt;strong>Token&lt;/strong> 以及 &lt;strong>Pos&lt;/strong> 兩 table 之後，即可透過 token 與 pos id 在 &lt;strong>Corpus&lt;/strong> 裡找到符合的列 (e.g., &lt;code>tk_id == 3&lt;/code> (&lt;code>我&lt;/code>) 且 &lt;code>pos_id == 1&lt;/code> (&lt;code>Nh&lt;/code>)。這些列裡面含有這個 token 於語料庫中的位置 (&lt;code>text_id&lt;/code>, &lt;code>sent_idx&lt;/code>, &lt;code>tk_idx&lt;/code>)。&lt;/li>
&lt;/ul>
&lt;h2 id="原始碼--使用語料庫">原始碼 / 使用語料庫&lt;/h2>
&lt;p>這個專案一開始是使用版權封閉的語料庫製作，因此語料庫的資料並未放在 GitHub，但後端的原始碼仍放在 &lt;a href="https://github.com/liao961120/kwic-backend">&lt;code>liao961120/kwic-backend&lt;/code>&lt;/a>。&lt;/p>
&lt;p>為了讓這個專案至少能被使用，我另外爬了 &lt;a href="https://github.com/liao961120/dcard-corpus">Dcard 作為語料&lt;/a> (500 多萬詞，大小約平衡語料庫的一半)，並包成 docker image，方便有興趣的人使用。要搜尋 Dcard 語料庫僅需依照下方的步驟：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>取得 docker image (僅第一次需執行)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker pull liao961120/dcard
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>執行後端 (執行後，請等待 cmd 出現 &lt;code>Corpus Loaded&lt;/code> 的字串)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -it -p 127.0.0.1:1420:80 liao961120/dcard
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>前往 &lt;a href="https://kwic.yongfu.name">https://kwic.yongfu.name&lt;/a> 使用前端界面&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>一開始曾想過直接使用現成的 corpus framework，例如 &lt;a href="http://cwb.sourceforge.net">CWB&lt;/a>, &lt;a href="https://inl.github.io/BlackLab">BlackLab&lt;/a> 等。但一方面研究這些 framework 要花許多精力，且因為研究的都是別人做好的 API，不容易學到比較低階、處理語料的問題。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>快速掃過 &lt;a href="https://cs50.harvard.edu/x/2019">CS50&lt;/a> 的前 5 堂課 (我還是不會 C/C++)、複習之前&lt;a href="https://cs50.harvard.edu/web/#sql">不怎麼認真看待的 SQL Database&lt;/a>以及閱讀 &lt;a href="https://www.sqlite.org/queryplanner.html">SQLite 關於 indexing 的說明文件&lt;/a> (這最重要)。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>雖然本來不打算做前端，但由於花了大量時間學習 Database 的概念，多花個幾小時刻個前端相比之下簡單許多 (這邊前端的功能不多)。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>這裡的語料是經&lt;a href="https://github.com/ckiplab/ckiptagger">中研院 ckiptagger&lt;/a> 斷詞，可&lt;a href="https://github.com/ckiplab/ckiptagger/wiki/POS-Tags">於此&lt;/a>檢視其詞類標記集。&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>建立資料庫以及索引的原始碼位於 &lt;a href="https://github.com/liao961120/dcard-corpus/blob/master/indexCorp.py">&lt;code>liao961120/dcard-corpus/indexCorp.py&lt;/code>&lt;/a>。&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description><category>Linguistics</category><category>Python</category><category>vue</category><category>docker</category><category>中文</category></item></channel></rss>