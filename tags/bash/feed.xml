<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bash on Yongfu's Blog</title><link>https://yongfu.name/tags/bash/</link><description>Recent content in bash on Yongfu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 28 Jul 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://yongfu.name/tags/bash/feed.xml" rel="self" type="application/rss+xml"/><item><title>Text Mining 前處理</title><link>https://yongfu.name/2018/07/28/quanteda-tutorial/</link><pubDate>Sat, 28 Jul 2018 00:00:00 +0000</pubDate><guid>https://yongfu.name/2018/07/28/quanteda-tutorial/</guid><description>
&lt;p>中文 Text Mining 的前處理比起其它以拉丁字母為主的文本困難許多，參考資源也相對龐雜不全。 這裡以較晚近出現的&lt;a href="https://quanteda.io/">&lt;code>quanteda&lt;/code>&lt;/a>套件為根據，依其需求進行中文文本前處理。&lt;/p>
&lt;p>選擇&lt;code>quanteda&lt;/code>而非其它較流行的套件如&lt;code>tm&lt;/code>的原因是因為其&lt;a href="https://github.com/quanteda/stopwords">多語言支持&lt;/a>較佳，譬如其內建的 tokenizer 能&lt;a href="https://koheiw.net/?p=339">直接對中文進行斷詞&lt;/a>。然而，由於 &lt;a href="https://github.com/fxsjy/jieba">&lt;code>jieba&lt;/code>&lt;/a>的社群資源以及斷詞效果較佳，此文還是以&lt;a href="https://github.com/qinwf/jiebaR">&lt;code>jiebaR&lt;/code>&lt;/a>進行斷詞。&lt;/p>
&lt;p>此外，因為使用的語料是簡體字，這裡也提到簡體、繁體轉換處理的相關資源。 我希望這篇文章能整理出一套中文文本前處理的架構，試圖減輕未來可能遇到的問題。&lt;/p>
&lt;div class="section level2">
&lt;h2>流程&lt;/h2>
&lt;img src="https://img.yongfu.name/blog/mermaid2.svg" alt="" style="width:100%">
&lt;div class="mermaid">
graph LR
html("HTML")
html -.->|"rvest"| df0
subgraph 前處理
df1("斷詞 data_frame")
df0("data_frame")
df0 -.->|"&lt;br> jiebaR &lt;br> (保留標點)&lt;br>"| df1
df1 -.->|"ropencc &lt;br> 簡轉繁"| df1
end
corp("Corpus")
token("Tokens")
subgraph quanteda
df1 -.->|"quanteda &lt;br> corpus()"| corp
corp -.->|"quanteda &lt;br> tokenize()"| token
end
html -.- bls(" ")
style bls fill:none,stroke:none
style html fill:#ccbdb9
style df1 fill:#92ff7f
linkStyle 5 stroke-width:0px,fill:none;
&lt;/div>
&lt;/div>
&lt;div class="section level2">
&lt;h2>資料爬取&lt;/h2>
&lt;p>這邊使用 &lt;a href="https://www.rstudio.com/">RStudio&lt;/a> 軟體工程師 &lt;a href="https://yihui.name/en/about/">Yihui&lt;/a> 的&lt;a href="https://yihui.name/cn/">中文部落格&lt;/a>文章作為練習素材。首先需要取得文章的網址，因此先到部落格的文章列表頁面(&lt;a href="https://yihui.name/cn/" class="uri">https://yihui.name/cn/&lt;/a>)，使用瀏覽器的&lt;a href="https://developers.google.com/web/tools/chrome-devtools/?hl=zh-tw">開發者工具&lt;/a>(按&lt;code>Ctrl + Shift + I&lt;/code>開啟)進行&lt;strong>觀察&lt;/strong>。&lt;/p>
&lt;p>接著使用&lt;a href="https://github.com/hadley/rvest">&lt;code>rvest&lt;/code>&lt;/a>套件擷取網頁中所有文章的連結，並將文章網址儲存成&lt;code>list_of_post.txt&lt;/code>：&lt;/p>
&lt;pre>&lt;code class="r">library(dplyr)
library(rvest)
list_of_posts &amp;lt;- read_html(&amp;quot;https://yihui.name/cn/&amp;quot;) %&amp;gt;%
html_nodes(&amp;quot;.archive&amp;quot;) %&amp;gt;% # 列表在 div.archive 之下
html_nodes(&amp;quot;p&amp;quot;) %&amp;gt;% # 文章標題在 &amp;lt;div&amp;gt; 下之 &amp;lt;p&amp;gt;
html_nodes(&amp;quot;a&amp;quot;) %&amp;gt;% html_attr(&amp;quot;href&amp;quot;) # 文章連結在 &amp;lt;p&amp;gt; 下之 &amp;lt;a&amp;gt;
readr::write_lines(list_of_posts, &amp;quot;yihui/list_of_post.txt&amp;quot;)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="r">head(list_of_posts, 2)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[1] &amp;quot;/cn/2018/10/middle-school-teachers/&amp;quot;
[2] &amp;quot;/cn/2018/10/potato-pancake/&amp;quot; &lt;/code>&lt;/pre>
&lt;pre>&lt;code class="r">tail(list_of_posts, 2)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[1] &amp;quot;/cn/2005/01/rtx/&amp;quot; &amp;quot;/cn/2005/01/20-13-00/&amp;quot;&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="r">length(list_of_posts)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[1] 1097&lt;/code>&lt;/pre>
&lt;p>可以看到總共有 1097 篇文章，時間從 2005 年到今年七月都有發文的紀錄。&lt;/p>
&lt;p>由於文章數量相當多，因此之後僅會下載部分文章，&lt;strong>避免造成伺服器負擔過大&lt;/strong>。下載網頁時，可以在 R 中直接使用&lt;code>rvest&lt;/code>(見下文&lt;strong>資料前處理&lt;/strong>)，但我比較建議使用 Bash&lt;a href="#fn1" class="footnoteRef" id="fnref1">&lt;sup>1&lt;/sup>&lt;/a>的&lt;code>wget&lt;/code>指令，才不會因為重複下載網頁造成伺服器負擔。&lt;/p>
&lt;p>在下載前，需先決定目標文章的網址&lt;code>sub_list&lt;/code>：&lt;/p>
&lt;pre>&lt;code class="r">library(stringr)
set.seed(2018) # 設隨機種子 固定隨機函數的結果
idx &amp;lt;- str_detect(list_of_posts, &amp;quot;2018|2015|2010&amp;quot;)
sub_list &amp;lt;- list_of_posts[idx]
sub_list &amp;lt;- sub_list[sample(seq_along(sub_list), 20)] %&amp;gt;% # 抽出 20 篇
str_replace_all(pattern = &amp;quot;^/&amp;quot;, # 將站內連結改為完整 url
replacement = &amp;quot;https://yihui.name/&amp;quot;) %&amp;gt;%
str_replace_all(pattern = &amp;quot;/$&amp;quot;, &amp;quot;/index.html&amp;quot;)
readr::write_lines(sub_list, &amp;quot;yihui/sublist.txt&amp;quot;)
# 給 Bash 用的
sub_list %&amp;gt;%
str_replace_all(&amp;quot;https://yihui.name/cn/&amp;quot;, &amp;quot;&amp;quot;) %&amp;gt;%
str_replace_all(&amp;quot;/index.html&amp;quot;, &amp;quot;&amp;quot;) %&amp;gt;%
str_replace_all(&amp;quot;/&amp;quot;, &amp;quot;-&amp;quot;) %&amp;gt;%
str_replace_all(&amp;quot;-$&amp;quot;, &amp;quot;&amp;quot;) %&amp;gt;%
readr::write_lines(&amp;quot;yihui/sublist_name.txt&amp;quot;)&lt;/code>&lt;/pre>
&lt;div id="bash-" class="section level3">
&lt;h3>Bash 指令下載網頁&lt;/h3>
&lt;blockquote>
&lt;p>無法使用 bash 指令者，可跳過此節&lt;/p>
&lt;/blockquote>
&lt;p>為了自動化下載網頁，我寫了一個簡單的 Bash script &lt;code>wget_list&lt;/code>，用法如下:&lt;/p>
&lt;ul>
&lt;li>&lt;code>wget_list &amp;lt;網址文字檔&amp;gt; &amp;lt;檔名文字檔&amp;gt;&lt;/code>&lt;a href="#fn2" class="footnoteRef" id="fnref2">&lt;sup>2&lt;/sup>&lt;/a>
&lt;ul>
&lt;li>&lt;code>&amp;lt;網址文字檔&amp;gt;&lt;/code>： 每一列(row)由一個網址組成&lt;/li>
&lt;li>&lt;code>&amp;lt;檔名文字檔&amp;gt;&lt;/code>： 每一列由一個名稱組成，每個名稱與&lt;code>&amp;lt;網址文字檔&amp;gt;&lt;/code>的網址對應&lt;/li>
&lt;/ul>&lt;/li>
&lt;/ul>
&lt;!--FOOTNOTE START-->
&lt;p>在這裡，執行下列指令即可下載網頁&lt;/p>
&lt;pre>&lt;code class="bash">cd yihui/html
wget_list ../sublist.txt ../sublist_name.txt
cd -&lt;/code>&lt;/pre>
&lt;p>&lt;strong>&lt;code>wget_list&lt;/code>&lt;/strong>:&lt;/p>
&lt;pre>&lt;code class="bash">#!/bin/bash
#&amp;lt;&amp;lt;&amp;lt; wget_list: dowload webpages listed in a file &amp;gt;&amp;gt;&amp;gt;#
### Argument 1 is the file of links, 1 url per row ###
### Argument 2 is the file of names, 1 name per row ###
file1=$1
file2=$2
## Get the number of lines in the link list
num_lines=$(wc -l $file1 | egrep -o '^[0-9]*')
## loop over the lines in file1, dowload the the file &amp;amp; name them as listed in file2
for (( i=1; i&amp;lt;=${num_lines}; ++i )); do
wget &amp;quot;$(sed -n ${i}p $file1)&amp;quot; \
-O &amp;quot;$(sed -n ${i}p $file2)&amp;quot;
done&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="section level2">
&lt;h2>資料前處理&lt;/h2>
&lt;p>在清理資料之前，需先剖析網頁結構(就如同之前剖析文章列表頁面一樣)。 這邊觀察&lt;a href="https://yihui.name/cn/2015/11/peer-review/">這篇文章&lt;/a>，大致可以找出這些資訊：&lt;/p>
&lt;pre>&lt;code class="r">path &amp;lt;- &amp;quot;https://yihui.name/cn/2015/11/peer-review/&amp;quot;
all &amp;lt;- read_html(path) %&amp;gt;%
html_nodes(&amp;quot;article&amp;quot;)
header &amp;lt;- all %&amp;gt;% html_nodes(&amp;quot;header&amp;quot;)
title &amp;lt;- header %&amp;gt;% # 文章標題
html_nodes(&amp;quot;h1&amp;quot;) %&amp;gt;% html_text()
post_date &amp;lt;- header %&amp;gt;% # 發文日期
html_node(&amp;quot;h3&amp;quot;) %&amp;gt;% html_text() %&amp;gt;%
str_extract(&amp;quot;201[0-9]-[0-9]{2}-[0-9]{2}&amp;quot;)
article &amp;lt;- all %&amp;gt;% # 內文
html_nodes(&amp;quot;p&amp;quot;) %&amp;gt;%
html_text() %&amp;gt;% paste(collapse = &amp;quot;\n&amp;quot;)
# 這裡將 chr vector collapse 至 1 個字串，
# 簡化資料結構，並以分行符號保留段落資訊
num_sec &amp;lt;- all %&amp;gt;% # 內文段落數
html_nodes(&amp;quot;p&amp;quot;) %&amp;gt;% length
links &amp;lt;- all %&amp;gt;% html_nodes(&amp;quot;p&amp;quot;) %&amp;gt;% # 內文連結
html_nodes(&amp;quot;a&amp;quot;) %&amp;gt;% html_attr(&amp;quot;href&amp;quot;)
link_text &amp;lt;- all %&amp;gt;% html_nodes(&amp;quot;p&amp;quot;) %&amp;gt;% # 內文連結標題
html_nodes(&amp;quot;a&amp;quot;) %&amp;gt;% html_text()&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="r">library(tibble)
df &amp;lt;- data_frame(title = title,
date = post_date,
content = article,
num_sec = num_sec,
links = list(links),
link_text = list(link_text)
)
df %&amp;gt;%
mutate(title = str_trunc(title, 8),
content = str_trunc(content, 8),
links = str_trunc(links, 8),
link_text = str_trunc(link_text, 8)) %&amp;gt;%
kable(&amp;quot;markdown&amp;quot;, align = &amp;quot;c&amp;quot;)&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th align="center">title&lt;/th>
&lt;th align="center">date&lt;/th>
&lt;th align="center">content&lt;/th>
&lt;th align="center">num_sec&lt;/th>
&lt;th align="center">links&lt;/th>
&lt;th align="center">link_text&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td align="center">同行评审&lt;/td>
&lt;td align="center">2015-11-11&lt;/td>
&lt;td align="center">看到这么一…&lt;/td>
&lt;td align="center">8&lt;/td>
&lt;td align="center">c(“ht…&lt;/td>
&lt;td align="center">c(“一则…&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>我們可以將上面的程式碼改寫成函數&lt;code>post_data()&lt;/code>，自動讀取文章並輸出 data frame：&lt;/p>
&lt;pre>&lt;code class="r">post_data &amp;lt;- function (path) {
all &amp;lt;- read_html(path) %&amp;gt;%
html_nodes(&amp;quot;article&amp;quot;)
header &amp;lt;- all %&amp;gt;% html_nodes(&amp;quot;header&amp;quot;)
title &amp;lt;- header %&amp;gt;% # 文章標題
html_nodes(&amp;quot;h1&amp;quot;) %&amp;gt;% html_text()
post_date &amp;lt;- header %&amp;gt;% # 發文日期
html_node(&amp;quot;h3&amp;quot;) %&amp;gt;% html_text() %&amp;gt;%
str_extract(&amp;quot;201[0-9]-[0-9]{2}-[0-9]{2}&amp;quot;)
article &amp;lt;- all %&amp;gt;% # 內文
html_nodes(&amp;quot;p&amp;quot;) %&amp;gt;%
html_text() %&amp;gt;% paste(collapse = &amp;quot;\n&amp;quot;)
# 這裡將 chr vector collapse 至 1 個字串，
# 簡化資料結構，並以分行符號保留段落資訊
num_sec &amp;lt;- all %&amp;gt;% # 內文段落數
html_nodes(&amp;quot;p&amp;quot;) %&amp;gt;% length
links &amp;lt;- all %&amp;gt;% html_nodes(&amp;quot;p&amp;quot;) %&amp;gt;% # 內文連結
html_nodes(&amp;quot;a&amp;quot;) %&amp;gt;% html_attr(&amp;quot;href&amp;quot;)
link_text &amp;lt;- all %&amp;gt;% # 內文連結標題
html_nodes(&amp;quot;p&amp;quot;) %&amp;gt;%
html_nodes(&amp;quot;a&amp;quot;) %&amp;gt;% html_text()
df &amp;lt;- tibble::data_frame(title = title,
date = post_date,
content = article,
num_sec = num_sec,
links = list(links),
link_text = list(link_text)
)
}&lt;/code>&lt;/pre>
&lt;p>接著，將所有文章讀取至一個 data frame &lt;code>all_post&lt;/code>：&lt;/p>
&lt;pre>&lt;code class="r">library(dplyr)
library(tidyr)
html_list &amp;lt;- list.files(&amp;quot;yihui/html/&amp;quot;) # 列出資料夾下的檔案
all_post &amp;lt;- vector(&amp;quot;list&amp;quot;, length(html_list))
for (i in seq_along(html_list)) {
path &amp;lt;- paste0(&amp;quot;yihui/html/&amp;quot;, html_list[i])
all_post[[i]] &amp;lt;- post_data(path)
}
all_post &amp;lt;- bind_rows(all_post) %&amp;gt;% arrange(desc(date))
head(all_post) %&amp;gt;%
mutate(title = str_trunc(title, 8),
content = str_trunc(content, 8),
links = str_trunc(links, 8),
link_text = str_trunc(link_text, 8)) %&amp;gt;%
kable(&amp;quot;markdown&amp;quot;, align = &amp;quot;c&amp;quot;)&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th align="center">title&lt;/th>
&lt;th align="center">date&lt;/th>
&lt;th align="center">content&lt;/th>
&lt;th align="center">num_sec&lt;/th>
&lt;th align="center">links&lt;/th>
&lt;th align="center">link_text&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td align="center">修辞还是真实&lt;/td>
&lt;td align="center">2018-06-21&lt;/td>
&lt;td align="center">说两封让我…&lt;/td>
&lt;td align="center">12&lt;/td>
&lt;td align="center">chara…&lt;/td>
&lt;td align="center">chara…&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="center">花椒香料&lt;/td>
&lt;td align="center">2018-05-31&lt;/td>
&lt;td align="center">古人似乎喜…&lt;/td>
&lt;td align="center">2&lt;/td>
&lt;td align="center">/cn/2…&lt;/td>
&lt;td align="center">去年的花椒&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td align="center">CSS 的…&lt;/td>
&lt;td align="center">2018-05-14&lt;/td>
&lt;td align="center">CSS 中…&lt;/td>
&lt;td align="center">15&lt;/td>
&lt;td align="center">c(“ht…&lt;/td>
&lt;td align="center">c(“查阅…&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="center">毛姆的文学回忆录&lt;/td>
&lt;td align="center">2018-05-04&lt;/td>
&lt;td align="center">前段时间看…&lt;/td>
&lt;td align="center">14&lt;/td>
&lt;td align="center">c(“/c…&lt;/td>
&lt;td align="center">c(“职业…&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td align="center">距离的组织&lt;/td>
&lt;td align="center">2018-05-03&lt;/td>
&lt;td align="center">前面《闲情…&lt;/td>
&lt;td align="center">5&lt;/td>
&lt;td align="center">/cn/2…&lt;/td>
&lt;td align="center">闲情赋&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="center">语言圣战的终结？&lt;/td>
&lt;td align="center">2018-04-19&lt;/td>
&lt;td align="center">一直以来我…&lt;/td>
&lt;td align="center">3&lt;/td>
&lt;td align="center">c(“ht…&lt;/td>
&lt;td align="center">c(“惊天…&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="section level3">
&lt;h3>直接從網路讀取&lt;/h3>
&lt;p>如果無法使用 Bash 指令下載網頁，可將上面程式碼的&lt;code>html_list&lt;/code>改為讀取&lt;code>sublist.txt&lt;/code>中的 url，並修改&lt;code>for&lt;/code>迴圈中的&lt;code>path&lt;/code>：&lt;/p>
&lt;pre>&lt;code class="r">html_list &amp;lt;- read_lines(&amp;quot;yihui/sublist.txt&amp;quot;) # 讀取 url
all_post &amp;lt;- vector(&amp;quot;list&amp;quot;, length(html_list))
for (i in seq_along(html_list)) {
path &amp;lt;- html_list[i]
all_post[[i]] &amp;lt;- post_data(path)
}
all_post &amp;lt;- bind_rows(all_post) %&amp;gt;% arrange(desc(date))&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="section level3">
&lt;h3>斷詞&lt;/h3>
&lt;p>在處理中文、日語等文本資料，需先經過斷詞處理，因為其不像英語等歐洲語言的文本，以空格表示字詞的界線。&lt;/p>
&lt;p>我們將使用&lt;code>jiebaR&lt;/code>套件的&lt;code>segment()&lt;/code>進行斷詞。由&lt;code>?segment()&lt;/code>查看其 documentation 可知&lt;strong>&lt;code>segment()&lt;/code>只吃文字檔或 一個句子&lt;/strong>，因此需先搞清楚&lt;code>all_post&lt;/code>的結構才能進行斷詞：&lt;/p>
&lt;p>&lt;code>all_post&lt;/code>: 20*5 的&lt;code>data_frame&lt;/code>，每列(row)為一篇文章 - $title: 每列為 1 個值 - $date: 每列為 1 個值 - $content: 每列為 1 個值，段落資訊藏在字串中的&lt;code>\n&lt;/code>符號 - $links: 每列為 1 個 list - $link_text: 每列為 1 個 list&lt;/p>
&lt;p>&lt;code>all_post$content&lt;/code>的結構相當簡單(一篇文章一個字串)，因此不須經過額外處理。其它變項不須斷詞處理，因此在此不加細談。&lt;/p>
&lt;div id="jiebarsegment" class="section level4">
&lt;h4>jiebaR::segment&lt;/h4>
&lt;p>因為&lt;code>all_post$content&lt;/code>簡單的結構符合&lt;code>jiebaR&lt;/code>套件的預設需求，但有時資料會比較複雜，因此記錄下來供未來參考。&lt;/p>
&lt;p>前面提到&lt;code>jiebaR::segment&lt;/code>只吃一個句子(一個字串)或文字檔，那如果丟一個 vector 給它會怎樣？答案是看&lt;code>worker()&lt;/code>的設定：&lt;/p>
&lt;pre>&lt;code class="r">library(jiebaR)
seg &amp;lt;- worker(symbol = T, bylines = F)
segment(c(&amp;quot;妳很漂亮&amp;quot;, &amp;quot;我不喜歡你&amp;quot;), seg)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[1] &amp;quot;妳&amp;quot; &amp;quot;很漂亮&amp;quot; &amp;quot; &amp;quot; &amp;quot;我&amp;quot; &amp;quot;不&amp;quot; &amp;quot;喜歡&amp;quot; &amp;quot;你&amp;quot; &lt;/code>&lt;/pre>
&lt;pre>&lt;code class="r">seg &amp;lt;- worker(symbol = T, bylines = T)
segment(c(&amp;quot;妳很漂亮&amp;quot;, &amp;quot;我不喜歡你&amp;quot;), seg)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[[1]]
[1] &amp;quot;妳&amp;quot; &amp;quot;很漂亮&amp;quot;
[[2]]
[1] &amp;quot;我&amp;quot; &amp;quot;不&amp;quot; &amp;quot;喜歡&amp;quot; &amp;quot;你&amp;quot; &lt;/code>&lt;/pre>
&lt;ol style="list-style-type: decimal">
&lt;li>&lt;p>&lt;code>bylines = F&lt;/code>：回傳 1 個 chr vector，其每個元素為 1 個詞。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;code>bylines = T&lt;/code>：回傳 1 個 list，其長度(元素的數量)等於輸入之 vector 的長度，每個元素為一個 chr vector。&lt;/p>&lt;/li>
&lt;/ol>
&lt;p>&lt;code>bylines = F&lt;/code>的設定在此符合我們的需求，並且為配合&lt;code>quanteda&lt;/code>套件的特性而將斷詞結果以一個字串(以空格分開字詞)而非一個 chr vector 的形式儲存。 以下&lt;strong>對第一篇文章進行斷詞&lt;/strong>：&lt;/p>
&lt;pre>&lt;code class="r">library(jiebaR)
all_post_seg &amp;lt;- all_post
seg &amp;lt;- worker(symbol = T, bylines = F)
all_post_seg$content[1] &amp;lt;- all_post$content[1] %&amp;gt;%
segment(seg) %&amp;gt;% paste(collapse = &amp;quot; &amp;quot;)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="r">all_post$content[1] %&amp;gt;% str_trunc(20)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[1] &amp;quot;说两封让我感到“我天，给亲友的书信...&amp;quot;&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="r">all_post_seg$content[1] %&amp;gt;% str_trunc(30)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[1] &amp;quot;说 两封 让 我 感到 “ 我 天 ， 给 亲友 的 ...&amp;quot;&lt;/code>&lt;/pre>
&lt;p>要處理所有文章，僅需外包一個 for loop：&lt;/p>
&lt;pre>&lt;code class="r">all_post_seg &amp;lt;- all_post
seg &amp;lt;- worker(symbol = T, bylines = F)
idx &amp;lt;- seq_along(all_post$content)
for (i in idx){
all_post_seg$content[i] &amp;lt;- all_post$content[i] %&amp;gt;%
segment(seg) %&amp;gt;% paste(collapse = &amp;quot; &amp;quot;)
}
head(all_post$content, 3) %&amp;gt;% str_trunc(20)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[1] &amp;quot;说两封让我感到“我天，给亲友的书信...&amp;quot;
[2] &amp;quot;古人似乎喜欢把花椒当香料用。在《古...&amp;quot;
[3] &amp;quot;CSS 中的位置（position...&amp;quot; &lt;/code>&lt;/pre>
&lt;pre>&lt;code class="r">head(all_post_seg$content, 3) %&amp;gt;% str_trunc(30)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[1] &amp;quot;说 两封 让 我 感到 “ 我 天 ， 给 亲友 的 ...&amp;quot;
[2] &amp;quot;古人 似乎 喜欢 把 花椒 当 香料 用 。 在 《 ...&amp;quot;
[3] &amp;quot;CSS 中 的 位置 （ position ） 属...&amp;quot; &lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="section level3">
&lt;h3>簡轉繁&lt;/h3>
&lt;p>&lt;a href="https://github.com/BYVoid/OpenCC">OpenCC&lt;/a> 是一個簡體字與繁體字轉換的專案，非常優秀，因為其不僅是單純字轉字，甚至處理了地區性的用法(如「軟體」vs.「软件」)。因此，其簡繁轉換的選項有非常多：&lt;/p>
&lt;ul>
&lt;li>&lt;code>s2t.json&lt;/code> Simplified Chinese to Traditional Chinese 簡體到繁體&lt;/li>
&lt;li>&lt;code>t2s.json&lt;/code> Traditional Chinese to Simplified Chinese 繁體到簡體&lt;/li>
&lt;li>&lt;code>s2tw.json&lt;/code> Simplified Chinese to Traditional Chinese (Taiwan Standard) 簡體到臺灣正體&lt;/li>
&lt;li>&lt;code>tw2s.json&lt;/code> Traditional Chinese (Taiwan Standard) to Simplified Chinese 臺灣正體到簡體&lt;/li>
&lt;li>&lt;code>s2hk.json&lt;/code> Simplified Chinese to Traditional Chinese (Hong Kong Standard) 簡體到香港繁體（香港小學學習字詞表標準）&lt;/li>
&lt;li>&lt;code>hk2s.json&lt;/code> Traditional Chinese (Hong Kong Standard) to Simplified Chinese 香港繁體（香港小學學習字詞表標準）到簡體&lt;/li>
&lt;li>&lt;code>s2twp.json&lt;/code> Simplified Chinese to Traditional Chinese (Taiwan Standard) with Taiwanese idiom 簡體到繁體（臺灣正體標準）並轉換爲臺灣常用詞彙&lt;/li>
&lt;li>&lt;code>tw2sp.json&lt;/code> Traditional Chinese (Taiwan Standard) to Simplified Chinese with Mainland Chinese idiom 繁體（臺灣正體標準）到簡體並轉換爲中國大陸常用詞彙&lt;/li>
&lt;li>&lt;code>t2tw.json&lt;/code> Traditional Chinese (OpenCC Standard) to Taiwan Standard 繁體（OpenCC 標準）到臺灣正體&lt;/li>
&lt;li>&lt;code>t2hk.json&lt;/code> Traditional Chinese (OpenCC Standard) to Hong Kong Standard 繁體（OpenCC 標準）到香港繁體（香港小學學習字詞表標準）&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/qinwf/ropencc">&lt;code>ropencc&lt;/code>&lt;/a>套件是 OpenCC 的 R 語言接口，其不在 CRAN 上，需以&lt;code>devtools&lt;/code>從 GitHub 下載：&lt;/p>
&lt;pre>&lt;code class="r">devtools::install_github(&amp;quot;qinwf/ropencc&amp;quot;)&lt;/code>&lt;/pre>
&lt;p>使用上非常容易：&lt;/p>
&lt;pre>&lt;code class="r">library(ropencc)
trans &amp;lt;- converter(TW2SP) # 臺灣用法轉大陸用法
run_convert(trans, &amp;quot;開放中文轉換軟體&amp;quot;)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[1] &amp;quot;开放中文转换软件&amp;quot;&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="r">trans &amp;lt;- converter(T2S) # 單純繁轉簡
run_convert(trans, &amp;quot;開放中文轉換軟體&amp;quot;)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[1] &amp;quot;开放中文转换软体&amp;quot;&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="r">trans &amp;lt;- converter(S2TWP) # 簡轉臺灣用法
run_convert(trans, &amp;quot;开放中文转换软件&amp;quot;)&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="nohighlight">[1] &amp;quot;開放中文轉換軟體&amp;quot;&lt;/code>&lt;/pre>
&lt;p>在此我使用&lt;code>S2TWP&lt;/code>轉換&lt;code>$content&lt;/code>；&lt;code>S2T&lt;/code>轉換&lt;code>$title&lt;/code>：&lt;/p>
&lt;pre>&lt;code class="r">library(ropencc)
all_post_seg$content &amp;lt;- run_convert(converter(S2TWP),
all_post_seg$content)
all_post_seg$title &amp;lt;- run_convert(converter(S2T),
all_post_seg$title)
head(all_post_seg) %&amp;gt;%
mutate(title = str_trunc(title, 8),
content = str_trunc(content, 8),
links = str_trunc(links, 8),
link_text = str_trunc(link_text, 8)) %&amp;gt;%
kable(&amp;quot;markdown&amp;quot;, align = &amp;quot;c&amp;quot;)&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th align="center">title&lt;/th>
&lt;th align="center">date&lt;/th>
&lt;th align="center">content&lt;/th>
&lt;th align="center">num_sec&lt;/th>
&lt;th align="center">links&lt;/th>
&lt;th align="center">link_text&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td align="center">修辭還是真實&lt;/td>
&lt;td align="center">2018-06-21&lt;/td>
&lt;td align="center">說 兩封 …&lt;/td>
&lt;td align="center">12&lt;/td>
&lt;td align="center">chara…&lt;/td>
&lt;td align="center">chara…&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="center">花椒香料&lt;/td>
&lt;td align="center">2018-05-31&lt;/td>
&lt;td align="center">古人 似乎…&lt;/td>
&lt;td align="center">2&lt;/td>
&lt;td align="center">/cn/2…&lt;/td>
&lt;td align="center">去年的花椒&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td align="center">CSS 的…&lt;/td>
&lt;td align="center">2018-05-14&lt;/td>
&lt;td align="center">CSS …&lt;/td>
&lt;td align="center">15&lt;/td>
&lt;td align="center">c(“ht…&lt;/td>
&lt;td align="center">c(“查阅…&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="center">毛姆的文學回憶錄&lt;/td>
&lt;td align="center">2018-05-04&lt;/td>
&lt;td align="center">前段時間 …&lt;/td>
&lt;td align="center">14&lt;/td>
&lt;td align="center">c(“/c…&lt;/td>
&lt;td align="center">c(“职业…&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td align="center">距離的組織&lt;/td>
&lt;td align="center">2018-05-03&lt;/td>
&lt;td align="center">前面 《 …&lt;/td>
&lt;td align="center">5&lt;/td>
&lt;td align="center">/cn/2…&lt;/td>
&lt;td align="center">闲情赋&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="center">語言聖戰的終結？&lt;/td>
&lt;td align="center">2018-04-19&lt;/td>
&lt;td align="center">一直 以來…&lt;/td>
&lt;td align="center">3&lt;/td>
&lt;td align="center">c(“ht…&lt;/td>
&lt;td align="center">c(“惊天…&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;div id="quanteda" class="section level2">
&lt;h2>quanteda&lt;/h2>
&lt;p>我們前面進行的資料前處理，已經將資料整理成符合&lt;a href="https://tutorials.quanteda.io/basic-operations/corpus/corpus/">&lt;code>quanteda::corpus()&lt;/code>輸入的格式&lt;/a>：&lt;/p>
&lt;blockquote>
&lt;p>A data frame consisting of a character vector for documents, and additional vectors for document-level variables&lt;/p>
&lt;/blockquote>
&lt;p>因此，依以下指令即可將&lt;code>all_post_seg&lt;/code>轉換成&lt;code>corpus&lt;/code>物件：&lt;/p>
&lt;pre>&lt;code class="r">library(quanteda)
corp &amp;lt;- corpus(all_post_seg,
docid_field = &amp;quot;title&amp;quot;,
text_field = &amp;quot;content&amp;quot;)
corp %&amp;gt;% summary() %&amp;gt;% as_data_frame() %&amp;gt;%
head(3) %&amp;gt;%
mutate(links = str_trunc(links, 8),
link_text = str_trunc(link_text, 8)) %&amp;gt;%
kable(&amp;quot;markdown&amp;quot;, align = &amp;quot;c&amp;quot;)&lt;/code>&lt;/pre>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th align="center">Text&lt;/th>
&lt;th align="center">Types&lt;/th>
&lt;th align="center">Tokens&lt;/th>
&lt;th align="center">Sentences&lt;/th>
&lt;th align="center">date&lt;/th>
&lt;th align="center">num_sec&lt;/th>
&lt;th align="center">links&lt;/th>
&lt;th align="center">link_text&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td align="center">修辭還是真實&lt;/td>
&lt;td align="center">217&lt;/td>
&lt;td align="center">375&lt;/td>
&lt;td align="center">15&lt;/td>
&lt;td align="center">2018-06-21&lt;/td>
&lt;td align="center">12&lt;/td>
&lt;td align="center">chara…&lt;/td>
&lt;td align="center">chara…&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td align="center">花椒香料&lt;/td>
&lt;td align="center">149&lt;/td>
&lt;td align="center">246&lt;/td>
&lt;td align="center">9&lt;/td>
&lt;td align="center">2018-05-31&lt;/td>
&lt;td align="center">2&lt;/td>
&lt;td align="center">/cn/2…&lt;/td>
&lt;td align="center">去年的花椒&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td align="center">CSS 的位置屬性以及如何居中對齊超寬元素&lt;/td>
&lt;td align="center">347&lt;/td>
&lt;td align="center">805&lt;/td>
&lt;td align="center">23&lt;/td>
&lt;td align="center">2018-05-14&lt;/td>
&lt;td align="center">15&lt;/td>
&lt;td align="center">c(“ht…&lt;/td>
&lt;td align="center">c(“查阅…&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>有了&lt;code>corpus&lt;/code>的資料結構後，即進入了下圖&lt;code>quanteda&lt;/code>的分析架構，也結束了資料前處理的階段，開始進入 EDA 的階段。&lt;/p>
&lt;img src="https://img.yongfu.name/blog/mermaid.svg" alt="">
&lt;div class="mermaid">
graph TD
C(Corpus)
token(Tokens)
AP["Positional analysis"]
AN["Non-positional analysis"]
dfm(DFM)
tidy("Tidy Text Format")
vis("Visualize")
C --> token
token --> dfm
token -.-> AP
dfm -.-> AN
tidy -->|"cast_dfm()"| dfm
dfm -->|"tidy()"| tidy
dfm -.- vis
tidy -.-> vis
AP -.- vis
style C stroke-width:0px,fill:#6bbcff
style token stroke-width:0px,fill:#6bbcff
style dfm stroke-width:0px,fill:#6bbcff
style tidy stroke-width:0px,fill:orange
linkStyle 6 stroke-width:0px,fill:none;
linkStyle 8 stroke-width:0px,fill:none;
&lt;/div>
&lt;p>&lt;a href="https://quanteda.io/">quanteda&lt;/a> 有相當完整的&lt;a href="https://tutorials.quanteda.io/">教學資源&lt;/a>，且有很多有用的函數。同時，&lt;a href="https://github.com/juliasilge/tidytext">&lt;code>tidytext&lt;/code>&lt;/a> 套件也能輕易與 &lt;code>quanteda&lt;/code> 配合，在 &lt;code>document-feature matrix&lt;/code> 與&lt;code>tidytext&lt;/code>所提倡的 &lt;strong>tidy data frame&lt;/strong>(one-token-per-document-per-row) 兩種資料結構間自由轉換。&lt;strong>tidy data frame&lt;/strong> 的格式與&lt;a href="https://github.com/tidyverse/ggplot2">&lt;code>ggplot2&lt;/code>&lt;/a>相吻合，有助於資料視覺化的進行。&lt;/p>
&lt;p>這裡選擇以&lt;code>quanteda&lt;/code>而非&lt;code>tidytext&lt;/code>作為主要架構的原因在於&lt;code>tidytext&lt;/code>的架構僅容許 &lt;strong>bag-of-words&lt;/strong> 的架構，但&lt;code>quanteda&lt;/code>除了 &lt;strong>bag-of-words&lt;/strong> 之外，還保有 &lt;strong>Positional analysis&lt;/strong> 的潛力。&lt;/p>
&lt;p>由於篇幅有限，這裡不多加細談&lt;code>quanteda&lt;/code>套件&lt;a href="#fn3" class="footnoteRef" id="fnref3">&lt;sup>3&lt;/sup>&lt;/a>。關於&lt;code>quanteda&lt;/code>的使用，可以參考 &lt;a href="https://tutorials.quanteda.io/">quanteda tutorial&lt;/a>，內容非常詳盡。&lt;/p>
&lt;/div>
&lt;div id="reproduce" class="section level2">
&lt;h2>Reproduce&lt;/h2>
&lt;p>這篇文章的原始碼在我的 &lt;a href="https://github.com/liao961120/blog/tree/master/post_source/quanteda-chinese">GitHub&lt;/a>，歡迎下載至自己的電腦執行。&lt;/p>
&lt;/div>
&lt;div class="section level2 unnumbered">
&lt;h2>參考資料&lt;/h2>
&lt;div id="refs" class="references">
&lt;div id="ref-silge2017">
&lt;p>Silge, Julia, and David Robinson. 2017. &lt;em>Text Mining with R: A Tidy Approach&lt;/em>. 1st ed. O’Reilly Media, Inc.&lt;/p>
&lt;/div>
&lt;div id="ref-watanabe2018">
&lt;p>Watanabe, Kohei, and Stefan Müller. 2018. “Quanteda Tutorials.” &lt;em>Quanteda Tutorials&lt;/em>. https://tutorials.quanteda.io/.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="footnotes">
&lt;ol>
&lt;li id="fn1">&lt;p>Mac 和 Linux 內建有 Bash，但 Windows 沒有。&lt;a href="#fnref1">↩&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn2">&lt;p>要能直接執行&lt;code>wget_list&lt;/code>需先給予其執行的權限，因此需設置&lt;code>chmod 755 &amp;lt;path to wget_list&amp;gt;&lt;/code>，並且將&lt;code>wget_list&lt;/code>置於 shell 會自動搜尋程式的地方(如&lt;code>/usr/bin/&lt;/code>)。&lt;/p>
&lt;p>另一個方法是不設置權限，直接執行&lt;code>wget_list&lt;/code>：&lt;br />
&lt;code>bash &amp;lt;path to wget_list&amp;gt; &amp;lt;file1&amp;gt; &amp;lt;file2&amp;gt;&lt;/code> &lt;!--FOOTNOTE END-->&lt;a href="#fnref2">↩&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn3">&lt;p>未來可能會發一篇續作。&lt;a href="#fnref3">↩&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/div>
&lt;p style="text-align:right;font-size:7px;margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:1px">
Last updated: 2018-11-10
&lt;/p>
&lt;style>
div.mermaid {
display:none;
}
&lt;/style></description><category>Text Mining</category><category>R</category><category>bash</category><category>中文</category></item></channel></rss>