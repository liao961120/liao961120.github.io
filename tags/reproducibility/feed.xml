<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>reproducibility on Yongfu's Blog</title><link>https://yongfu.name/tags/reproducibility/</link><description>Recent content in reproducibility on Yongfu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 15 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://yongfu.name/tags/reproducibility/feed.xml" rel="self" type="application/rss+xml"/><item><title>A Minimalist Structure for Snakemake</title><link>https://yongfu.name/2023/02/15/snakemake/</link><pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate><guid>https://yongfu.name/2023/02/15/snakemake/</guid><description>&lt;p>I have &lt;a href="https://kbroman.org/minimal_make">heard of&lt;/a> the use of &lt;a href="https://www.gnu.org/software/make/">GNU Make&lt;/a> for enhancing
reproducibility for some time. I did not incorporate Make into my work however,
since a simple build script written in Bash was sufficient. Everything was well
in control, and I could structure the workflow to my will.&lt;/p>
&lt;p>It was not until I started working in a company setting that I found most things
out of my control. Decades of conventions have been accumulating and passing on,
and personal workflows have to fit into existing ones. In order to fit into my
company&amp;rsquo;s conventions of data analysis (which pretty much just ignore analysis
reproducibility), the number of scripts grew exponentially and quickly fell out
of my control (see figure below, which is automatically generated by Snakemake).
I needed a way to document and track my workflow in a consistent and scalable
manner. This was when I picked up Prof. Broman&amp;rsquo;s &lt;a href="https://kbroman.org/minimal_make">great introductory post&lt;/a>
on GNU Make again. Everything seemed hopeful, but I was soon defeated by the
omnipresent Windows. Since it is required to work onSome Notes for as
Windows machines in my
company, and since &lt;a href="http://gnuwin32.sourceforge.net/packages/make.htm">Make for Windows&lt;/a> has difficulties dealing with
Chinese file paths, I had to give up on Make. &lt;a href="https://snakemake.github.io">Snakemake&lt;/a> then came as my
savior.&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://img.yongfu.name/posts/dag.png" alt="Data analysis workflow graph generated by Snakemake">
&lt;figcaption>Data analysis workflow graph generated by Snakemake&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h2 id="meeting-snakemake">Meeting Snakemake&lt;/h2>
&lt;p>Snakemake was inspired by, but way more complicated than, GNU Make. Since it is
backed by Python, cross-platform issues such as character encodings are
automatically resolved. Snakemake is a thoughtful project that was originally
developed to facilitate computational research and reproducibility. Thus, it may
take some time to get started since there are many concepts to pick up. It&amp;rsquo;s
totally worth it, however. Dealing with complex tasks requires a complicated
framework. Often, these complications make sense (and are appreciated) only
after we face real-world complex tasks. Going through &lt;a href="https://snakemake.readthedocs.io/en/stable/tutorial/tutorial.html">Snakemake&amp;rsquo;s
tutorial&lt;/a> and experimenting with it on the computer would be sufficient
to get an average user started. It is not as complicated as it seems at first
glance.&lt;/p>
&lt;h2 id="snakemake-recommended-workflow">Snakemake Recommended Workflow&lt;/h2>
&lt;p>A great thing about Snakemake is that it is &lt;a href="https://stackoverflow.com/a/82064">opinionated&lt;/a>. This means
that certain conventions&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> are proposed, and most users would benefit
from these conventions since they spare the burden of structuring the workflow.&lt;/p>
&lt;p>For instance, Snakemake &lt;a href="https://snakemake.readthedocs.io/en/stable/snakefiles/deployment.html#distribution-and-reproducibility">recommends&lt;/a> the directory structure listed
below for every Snakemake workflow. This structure is so simple that its genius
might not be obvious at first glance. There are four directories in the project
root&amp;mdash;&lt;code>workflow/&lt;/code>, &lt;code>config/&lt;/code>, &lt;code>results/&lt;/code>, and &lt;code>resources/&lt;/code>. &lt;code>workflow/&lt;/code> holds
the &lt;em>coding&lt;/em> stuff. Code for data analysis, computation, and reproducibility are
all found in this directory. &lt;code>config/&lt;/code> is for optional configuration and I would
skip it here (in my own project, I did not use config files since the
&lt;code>Snakefile&lt;/code> is sufficient for my purposes). &lt;code>results/&lt;/code> and &lt;code>resources/&lt;/code> are what
(I think) make this structure fantastic. &lt;code>resources/&lt;/code> holds all &lt;strong>raw data&lt;/strong>,
i.e., data that are not reproducible on your computer (e.g., manually annotated
data). All data resulting from the computation in the current project are
located in &lt;code>results/&lt;/code>. So ideally, you could delete &lt;code>results/&lt;/code> at any time
without worry. A single command &lt;code>snakmake -c&lt;/code> should generate all the results
from &lt;code>resources/&lt;/code>. The genius of this structure is that it eliminates the need
of worrying about where to place newly arrived data, as commonly encountered in
real-world situations (e.g., an analysis might require data that you did not
foresee).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>├── .gitignore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── README.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── workflow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── rules
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| │ ├── module1.smk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| │ └── module2.smk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── scripts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| │ ├── script1.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| │ └── script2.R
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| └── Snakefile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── config.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── results
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── resources
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="an-enhanced-snakemake-workflow">An Enhanced Snakemake Workflow&lt;/h2>
&lt;p>I adopted the workflow above in my work. It was great, but I still found &lt;strong>two
annoying drawbacks&lt;/strong>.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Long directory names&lt;/strong>&lt;/p>
&lt;p>Since in a &lt;code>Snakefile&lt;/code>, file paths of inputs and outputs are always
repeated, it soon becomes annoying to type in paths starting with
&lt;code>resources/...&lt;/code> and &lt;code>results/...&lt;/code>. In addition, &amp;ldquo;resources&amp;rdquo; and &amp;ldquo;results&amp;rdquo;
have a common prefix, which often confuses me. It would be better off if the
two terms are more readily distinguished visually.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Confusing relative paths&lt;/strong>&lt;/p>
&lt;p>According to the &lt;a href="https://snakemake.readthedocs.io/en/latest/project_info/faq.html#how-does-snakemake-interpret-relative-paths">documentation&lt;/a>, relative paths in different
directives are &lt;strong>interpreted differently&lt;/strong>. To be short, relative paths in
&lt;code>input:&lt;/code>, &lt;code>output:&lt;/code>, and &lt;code>shell:&lt;/code> are interpreted relative to the working
directory (i.e., where you invoke the command &lt;code>snakemake -c&lt;/code>), whereas in
directives such as &lt;code>script:&lt;/code>, they are interpreted as relative to the
&lt;code>Snakefile&lt;/code>. So it would be cognitively demanding to switch back and forth
between the reference points of relative paths while writing the
&lt;code>Snakefile&lt;/code>. Why not have all paths relative to the project root?&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>To deal with the aforementioned problems, I modified the recommended directory
structure and arrived at the structure below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>├── README.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── Snakefile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── made
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── raw
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── src
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>
&lt;p>&lt;strong>Simplified directory names&lt;/strong>&lt;/p>
&lt;p>&lt;code>resources/&lt;/code> is renamed as &lt;code>raw/&lt;/code>, and &lt;code>results/&lt;/code> is renamed as &lt;code>made/&lt;/code>. The
&lt;code>workflow/&lt;/code> directory is broken down into &lt;code>src/&lt;/code> (holding scripts) and the
&lt;code>Snakefile&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Consistent relative paths&lt;/strong>&lt;/p>
&lt;p>Since &lt;code>Snakefile&lt;/code> is now placed in the project root, the problem of
different relative paths for different directives is resolved, as long as
the user always invokes the command &lt;code>snakemake -c&lt;/code> in the project root.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>The source code of this Snakemake workflow can be found
&lt;a href="https://github.com/liao961120/minimal-snake">here on GitHub&lt;/a>.&lt;/p>
&lt;h2 id="some-notes-for-using-git-bash-as-shell">Some Notes for Using Git-Bash as Shell&lt;/h2>
&lt;p>The experience of using Snakemake on Windows is great overall. I have run into a
few problems, but the problems were usually solvable. There is one particular
problem that took me a while to solve. On Windows, the default shell executable
used in Snakemake (and Python) is Cmd (or maybe Powershell). But since I am more
familiar with Bash and Unix tools, it is a real inconvenience. I had setup
Git-Bash on the company&amp;rsquo;s Windows machine but then spent a long time figuring
out how to set Git-Bash as the default shell in Snakemake. The information for
Snakemake users on Windows is scarce. I guess Snakemake is just unpopular among
Windows users. After reading the &lt;a href="https://snakemake.readthedocs.io/en/v6.15.2/_modules/snakemake/shell.html">source code&lt;/a>, the solution turned
out to be quite simple. Just put the code below at the top of the &lt;code>Snakefile&lt;/code>
and place the path to Git-Bash executable in &lt;code>shell.executable()&lt;/code>. This will
allow the identical &lt;code>Snakefile&lt;/code> to be used on both Windows and Unix-like
computers without additional configurations.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Additional setup for running with git-bash on Windows&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;nt&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">from&lt;/span> snakemake.shell &lt;span style="color:#f92672">import&lt;/span> shell
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shell&lt;span style="color:#f92672">.&lt;/span>executable(&lt;span style="color:#e6db74">r&lt;/span>&lt;span style="color:#e6db74">&amp;#39;C:\Users\rd\AppData\Local\Programs\Git\bin\bash.exe&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&amp;ldquo;Good&amp;rdquo; conventions here, as opposed to naturally-resulting conventions without the consideration of reproducibility.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description><category>workflow</category><category>python</category><category>r</category><category>reproducibility</category></item></channel></rss>